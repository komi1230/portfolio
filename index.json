[{"body":"About RESTful API REST is abbreviation of REpresentational State Transfer, and is principles of architecturing to cooperate multiple softwares in distributed system, advocated by Roy Fielding in 2000. REST is composed of four principles:\n Addressability  Addressability means all offered information can be represented via URI and each information has unique address represented by URI.   Stateless  Stateless means API should be stateless client/server protocol based on HTTP. State is not managed by session, each handled information is complete and interpretable by itself.   Connectability  Connectability means each information can be linked to another inside itself.   Uniform Interface  Uniform Interface means every operation has to use HTTP method.    Example Each is really abstract and difficult to understand. Let\u0026rsquo;s take some easy examples.\nCase1 If you want to search about Japanese food, search software should offer these URI.\nGET /search/sushi GET /search/tenpura URI has to represent resources. In this example, you can easily understand what each URI represent.\nOn the other hand, this is bad:\nGET /search/sushi GET /i-want-to-know/tenpura Both means the same but the representation is different. The same operation should be summarized.\nCase2 Assume you are making some SNS. SNS offers user accounts and they can be deleted.\nWhen you delete account, this API should be following.\nDELETE /account/1 Bad pattern is like this:\nGET /account/1/delete In REST API, URI shouldn\u0026rsquo;t be composed of verb, and it has to represent resources. In this bad case, /delete is not resource but operation.\n","categories":["Tech"],"date":1602460800,"description":"REST is a principle of API architecturing and make system clean and maintainable. This article is about RESTful API and shows its examples.","permalink":"http://komi.dev/post/2020-10-12-follow-rest-api/","publishdate":"2020-10-12T00:00:00Z","section":"post","tags":["REST","Architecture"],"title":"Design RESTful API","url":"/post/2020-10-12-follow-rest-api/"},{"body":"","categories":null,"date":1602460800,"description":"","permalink":"http://komi.dev/post/","publishdate":"0001-01-01T00:00:00Z","section":"post","tags":null,"title":"Posts","url":"/post/"},{"body":"Fullscreen as default In writing code, I like wide screen, fullscreen is the best.\nThis setting makes Emacs start with fullscreen.\n(toggle-frame-fullscreen) Vertical Split My Emacs\u0026rsquo; screen is split vertically, and the left is editor and the right is Terminal (eshell).\nWhen splitting, the screen will be split horizontally as default. So if Emacs finds this setting in loading init.el file, Emacs will split vertically.\n(split-window-right) My screen is like this.\n Eshell This is the most favorite part of Emacs for me. As long as you have EShell, Terminal is not needed.\nThere are two kinds of Emacs user; ones who use Emacs in terminal and others who use terminal in Emacs.\nEshell enables the latter.\nM-x eshell Emacs has some kinds of terminal. Famous ones are term, shell and eshell.\nI think eshell is the best choice. The reason for this is following.\n shell is not stable because my zshrc is not properly loaded. term is stable and my zshrc is properly loaded, but it\u0026rsquo;s slow.  On the other hand, ehsell is written in Emacs Lisp and it\u0026rsquo;s installed as default. Commands are a little different from standard terminal but commands are based on Emacs. For example, in standard terminal Ctrl-c means to kill process, but in ehsell it\u0026rsquo;s C-c C-k.\nEshell can be substituted with terminal.\n","categories":["Tech"],"date":1601337600,"description":"Emacs has many standard functions and nifty settings. This article introduces some of those.","permalink":"http://komi.dev/post/2020-09-29-tips-emacs/","publishdate":"2020-09-29T00:00:00Z","section":"post","tags":["Emacs"],"title":"Small Tips in Emacs","url":"/post/2020-09-29-tips-emacs/"},{"body":"About Tinysearch Tinysearch is a full-text search engine for static websites built with Rust and Wasm. This is very useful and easy to use in our static site like this blog. And also blazingly fast. This is because tinysearch works with WebAssembly and runs much faster than JavaScript.\nIn searching, tinysearch loads JSON file (like this, this blog\u0026rsquo;s article information) for search target, browse with search query and output the results which are matched.\nRepository is here.\nGet Tinysearch If you have Cargo, just run:\n$ cargo install tinysearch Tinysearch works this itself but needs binaryen in optimization. You can get binaryen in somw ways, but if your environment is macOS and have Homebrew, Homebrew is the easiest way to get:\n$ brew install binaryen When you want to optimize, all you have to do is just attach flag -o in use.\n$ tinysearch -o {path/to/json} Install Tinysearch in Hugo Dump JSON The next step, setup Hugo.\nAs I described above, Tinysearch requires JSON file which includes articles\u0026rsquo; information (contents, URL and title). So we have to get Hugo to output JSON file.\nIn Hugo, there is layouts/ directory, which can handle the structure and design of the site. To get Hugo to output JSON, we have to build a template in layouts/_default/list.json.json. This file is like this:\n[ {{ range $index , $e := .Site.RegularPages }}{{ if $index }}, {{end}}{{ dict \u0026#34;title\u0026#34; .Title \u0026#34;url\u0026#34; .Permalink \u0026#34;body\u0026#34; .Plain | jsonify }}{{end}} ] With this list.json.json, a JSON file which is about articles is automatically generated in public/index.json when the site is built.\nThis syntax is Hugo\u0026rsquo;s one, so you can easily change this. For example, my blog\u0026rsquo;s theme has a little complicated structure and my list.json.json is like this:\n{{/* Generates a valid Algolia search index */}} {{- $.Scratch.Add \u0026#34;index\u0026#34; slice -}} {{- $section := $.Site.GetPage \u0026#34;section\u0026#34; .Section }} {{- range .Site.AllPages -}} {{- if and (eq .Section \u0026#34;post\u0026#34;) (or (and (.IsDescendant $section) (and (not .Draft) (not .Params.private))) $section.IsHome) -}} {{- $.Scratch.Add \u0026#34;index\u0026#34; (dict \u0026#34;date\u0026#34; .Date.UTC.Unix \u0026#34;description\u0026#34; .Description \u0026#34;permalink\u0026#34; .Permalink \u0026#34;publishdate\u0026#34; .PublishDate \u0026#34;title\u0026#34; .Title \u0026#34;url\u0026#34; .RelPermalink \u0026#34;section\u0026#34; .Section \u0026#34;tags\u0026#34; .Params.Tags \u0026#34;categories\u0026#34; .Params.Categories \u0026#34;body\u0026#34; .Plain)}} {{- end -}} {{- end -}} {{- $.Scratch.Get \u0026#34;index\u0026#34; | jsonify -}} This crawls only files in content/post/. The template in above crawls other article (i.e. like /top/about/).\nTinysearch requires only 3 key-value pairs: \u0026ldquo;title\u0026rdquo;: .Title, \u0026ldquo;url\u0026rdquo;: .Permalink and \u0026ldquo;body\u0026rdquo;: .Plain. There are many key-value pairs in my example. This is because I will extend search engine in the future. You don\u0026rsquo;t have to make like this.\nBuild WebAssembly Next, we build WebAssebly with Tinysearch.\nNow you have JSON file in public/index.json, and we will build WebAssembly with this. Make directory named wasm in static/ to store WebAssembly files.\nTo build WebAssembly files, this is easy, just do this:\n$ ce static/wasm $ tinysearch ../../public/index.json Then, you can find some files generated.\n$ ls static/wasm demo.html tinysearch_engine.d.ts tinysearch_engine_bg.wasm.d.ts package.json tinysearch_engine.js storage tinysearch_engine_bg.wasm It\u0026rsquo;s almost done ! Let\u0026rsquo;s check demo.html.\n$ miniserve You can see this page.\n JavaScript code of this is like this:\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { search, default as init } from \u0026#39;./tinysearch_engine.js\u0026#39;; window.search = search; async function run() { await init(\u0026#39;./tinysearch_engine_bg.wasm\u0026#39;); } run(); \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function doSearch() { let value = document.getElementById(\u0026#34;demo\u0026#34;).value; const arr = search(value, 10); let ul = document.getElementById(\u0026#34;results\u0026#34;); ul.innerHTML = \u0026#34;\u0026#34;; for (i = 0; i \u0026lt; arr.length; i++) { var li = document.createElement(\u0026#34;li\u0026#34;); let elem = arr[i]; let elemlink = document.createElement(\u0026#39;a\u0026#39;); elemlink.innerHTML = elem[0]; elemlink.setAttribute(\u0026#39;href\u0026#39;, elem[1]); li.appendChild(elemlink); ul.appendChild(li); } } \u0026lt;/script\u0026gt; What is done here is really easy; load WebAssembly file and run its functions. doSearch() handles input value which means search query and runs Tinysearch for each input.\nTo enable article search, what you have to do is to write some template. For example, this blog is like this.\nMy GitHub repositoy about this blog is really informative. Good luck !\n","categories":["Tech"],"date":1600819200,"description":"Tinysearch is a really fast search engine working in client side. This article tells how to use tinysearch and use it with Hugo.","permalink":"http://komi.dev/post/2020-09-23-introduction-tinysearch/","publishdate":"2020-09-23T00:00:00Z","section":"post","tags":["Rust","Hugo"],"title":"Install Tinysearch in Hugo","url":"/post/2020-09-23-introduction-tinysearch/"},{"body":"Process input data in front end Material-UI is reallly convenient package for non-designer because programmer can easily make awesome design. And Material-UI has a variety of components, which are easy-to-custommize.\n To get data from user\u0026rsquo;s input, in normal HTML, we use \u0026lt;input\u0026gt; tag. But we have to store data into some variable to process data with JavaScript.\nIn practice You can easily make simple page with Textfield.\nimport React from \u0026#39;react\u0026#39;; import TextField from \u0026#39;@material-ui/core/TextField\u0026#39;; export default function OurForm() { return ( \u0026lt;TextField label=\u0026#34;Label\u0026#34; /\u0026gt; ); } And UI is like this.\n With this, We can accept user input. But we cannnot process data, for example console.log(data).\nOK, we will do it. All we have to do is use useState.\nimport React from \u0026#39;react\u0026#39;; import TextField from \u0026#39;@material-ui/core/TextField\u0026#39;; export default function OurForm() { const [data, setData] = React.useState(\u0026#34;\u0026#34;); const handleSetData = (event) =\u0026gt; { setData(event.target.value); } return ( \u0026lt;TextField label=\u0026#34;Label\u0026#34; value={data} onChange={handlleSetData} /\u0026gt; ); } In pure React, it\u0026rsquo;s very difficult to manage components\u0026rsquo; states. We can do it by using Redux, but useState is easier way to controll states.\nHere we already controll users\u0026rsquo; input data.\n","categories":["Tech"],"date":1600214400,"description":"Material-UI is a very good package to construct UI easily in React. This article provides how to get data from input form.","permalink":"http://komi.dev/post/2020-09-16-material-ui-textfield-var/","publishdate":"2020-09-16T00:00:00Z","section":"post","tags":["React"],"title":"How to get data from Textfield of Material-UI","url":"/post/2020-09-16-material-ui-textfield-var/"},{"body":"Global variable in Rust In functional programming, the way to use global variable properly is just to avoid using it. This is not a joke. Modern software engineering requires variables to be scoped, and at the same time, they shouldn\u0026rsquo;t be changed even in scopes such as closures.\nHowever, we can\u0026rsquo;t sometimes avoid using global variable (Somtimes codes can be cleaner.) For such situations, Rust provides some syntax to controll global variables.\nThey are const and static.\nTo explain their functionality, let\u0026rsquo;s take a easy example.\nconstX: usize =0;fn main(){println!(\u0026#34;X = {}\u0026#34;,X);X+=1;println!(\u0026#34;X = {}\u0026#34;,X);}When you try to compile this, you will face an error message.\nerror[E0067]: invalidleft-handsideofassignment--\u0026gt; src/main.rs:5:5|5|X+=1;|-^^|||cannotassigntothisexpressionconst variable can\u0026rsquo;t be changed and can be accessed from any place.\nOn the other hand, this is compilable.\nconstX: usize =0;fn main(){unsafe{println!(\u0026#34;X = {}\u0026#34;,X);X+=1;println!(\u0026#34;X = {}\u0026#34;,X);}}This uses unsafe but static allows us to change itself.\nOK, the next example is more clear.\nusestd::sync::atomic::{self,AtomicUsize};constX: AtomicUsize=AtomicUsize::new(0);staticY: AtomicUsize=AtomicUsize::new(0);fn main(){for_in0..5{println!(\u0026#34;X = {}\u0026#34;,X.fetch_add(1,atomic::Ordering::SeqCst));}for_in0..5{println!(\u0026#34;Y = {}\u0026#34;,Y.fetch_add(1,atomic::Ordering::SeqCst));}}This code is from here. When you run, this prints below.\nX = 0 X = 0 X = 0 X = 0 X = 0 Y = 0 Y = 1 Y = 2 Y = 3 Y = 4 fetch_add takes \u0026amp;self, so \u0026amp;X and \u0026amp;Y are calculated in this example. About const, some anonymous local variable is allocated for each time, so the const variable looks unchanged. In short, new variable initialized as AtomicUsize is generated for each iteration.\nBut static fixes the address of the variable. So this is incremented for each iteration., which has 'static lifetime.\nTo summarize, the difference between const and static is:\n const defines the value determined in compiling. This fixes value, not address. static defines the address, which will be set value in compiling. It isn\u0026rsquo;t essential whether this is initialzied with value.  How to use properly const is really simple and easy to use. But static is a little diffucult to understand and use. In fact, static has cause to really step in it.\nWhen you set global variable initialized with static mut, this often results in undefined behaviour. For example, see this link.\n#[derive(Debug, Clone)]struct Node{children: Vec\u0026lt;usize\u0026gt;,last: usize,}implNode{fn add(\u0026amp;mutself,next: usize)-\u0026gt; usize {self.children.push(next);self.last=next;next}}staticmutNODES: Vec\u0026lt;Node\u0026gt;=Vec::new();unsafefn new_node()-\u0026gt; usize {letret=NODES.len();NODES.push(Node{children: Vec::new(),last: 0});ret}fn main(){unsafe{letmutlast=new_node();for_in0..30{last=NODES[last].add(new_node());}fornodein\u0026amp;NODES{println!(\u0026#34;{}\u0026#34;,node.last);}}}In this code, NODES should be set as 0 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; \u0026hellip; -\u0026gt; 30. But the result is below.\n123056709101112131415017181920212223242526272829300The reason for such a phenomenon is static mut has global pointer.\nTo avoid this, you should avoid using global variable. Or use thread_local! macro.\nGlobal poiter can be dangerous, so it\u0026rsquo;s safer to restrict scope of global variable.\nthread_local! and lazy_static! thread_local! macro thread_local! is really useful to handle safely global variable. This macro allocates static data like raw static but this allocates for each thread (not global).\nusestd::cell::RefCell;thread_local!{staticX: RefCell\u0026lt;usize\u0026gt;=RefCell::new(0);}fn main(){X.with(|a|{*a.borrow_mut()+=1;})}To use it, you have to borrow with with method and make closure.\nYou can use static data safely without undefined behaviour.\nlazy_static! macro If you want to initialize global variable with some data (ex. File I/O), this is useful. There are some situations where you want to read some configuration files or dictionary data in advance and put the contents of those files globally.\nIn Rust, it is possible to create global variables by using static, but it is not usable in the above situation because the expression used for initialization must be evaluated at compile time.\n#[macro_use]externcratelazy_static;usestd::sync::Mutex;lazy_static::lazy_static!{staticrefX: Mutex\u0026lt;usize\u0026gt;=Mutex::new(0);}fn main(){*X.lock().unwrap()+=1;}","categories":["Tech"],"date":1599868800,"description":"Rust provides some syntax to allocate data to be able to be accessed globally. This article tells when you use properly.","permalink":"http://komi.dev/post/2020-09-12-when-to-use-lazy_static/","publishdate":"2020-09-12T00:00:00Z","section":"post","tags":["Rust"],"title":"const and static in Rust","url":"/post/2020-09-12-when-to-use-lazy_static/"},{"body":"Do you know Emacs? Today there are many editors. The most popular one seems Visual Stadio Code. Nobody can complain about this fact. And the second one may be Vim. Nobody can also complain about this.\nBut\u0026hellip;Well\u0026hellip; By the say, do you know Emacs?\nEmacs is a kind of editors and has so long history. Today, a few people use this. I\u0026rsquo;m not sure why Emacs is not popular because I think this is really customizable and light-weighted. Maybe many people consider Emacs to be an ancient weapon.\nBut here I declare that Emacs still lives today. One of the features and merits of Emacs is easy to customize. From my point of view, Emacs is shell or OS rather than editor. In Emacs, you can watch YouTube, send mails or play video games.\nIn this article, I\u0026rsquo;ll describe how to setup Emacs to be modern IDE.\nMy Environment  This is my environment. Not VSCode. My environment has really rich UI and also blazingly fast.\nNeotree Neotree is a emacs tree plugin like NerdTree for Vim.\n In ~/.emacs.d/init.el, the setting is like this:\n;; neotree (use-package neotree :after projectile :commands (neotree-show neotree-hide neotree-dir neotree-find) :custom (neo-theme \u0026#39;nerd2) :bind (\u0026#34;\u0026lt;f9\u0026gt;\u0026#34; . neotree-projectile-toggle) :preface (defun neotree-projectile-toggle () (interactive) (let ((project-dir (ignore-errors ;;; Pick one: projectile or find-file-in-project (projectile-project-root) )) (file-name (buffer-file-name)) (neo-smart-open t)) (if (and (fboundp \u0026#39;neo-global--window-exists-p) (neo-global--window-exists-p)) (neotree-hide) (progn (neotree-show) (if project-dir (neotree-dir project-dir)) (if file-name (neotree-find file-name))))))) (global-set-key \u0026#34;\\C-o\u0026#34; \u0026#39;neotree-toggle) To show or hide, set key as Ctrl-o.\nMinimap Minimap shows minimap in the side buffer.\n Setting is like below.\n;; Minimap (use-package minimap :commands (minimap-bufname minimap-create minimap-kill) :custom (minimap-major-modes \u0026#39;(prog-mode)) (minimap-window-location \u0026#39;right) (minimap-update-delay 0.2) (minimap-minimum-width 20) :bind (\u0026#34;M-t m\u0026#34; . ladicle/toggle-minimap) :preface (defun ladicle/toggle-minimap () \u0026#34;Toggle minimap for current buffer.\u0026#34; (interactive) (if (null minimap-bufname) (minimap-create) (minimap-kill))) :config (custom-set-faces \u0026#39;(minimap-active-region-background ((((background dark)) (:background \u0026#34;#555555555555\u0026#34;)) (t (:background \u0026#34;#C847D8FEFFFF\u0026#34;))) :group \u0026#39;minimap))) Git-gutter In modern software engineering, git is an essential for engineer team. Git-gutter make\n Setting is below. You can change color or sign.\n;; git-gutter (use-package git-gutter :custom (git-gutter:modified-sign \u0026#34;~\u0026#34;) (git-gutter:added-sign \u0026#34;+\u0026#34;) (git-gutter:deleted-sign \u0026#34;-\u0026#34;) :custom-face (git-gutter:modified ((t (:background \u0026#34;#f1fa8c\u0026#34;)))) (git-gutter:added ((t (:background \u0026#34;#50fa7b\u0026#34;)))) (git-gutter:deleted ((t (:background \u0026#34;#ff79c6\u0026#34;)))) :config (global-git-gutter-mode +1)) lsp-mode Modern editors should have rich auto completion. In Emacs, lsp-mode can offer you rich UI and cool experience.\nIn my environment, lsp-mode is used with company and yasnippet.\n;; Company (require \u0026#39;company) (global-company-mode) ; Turn on in all buffers (setq company-transformers \u0026#39;(company-sort-by-backend-importance)) ;; Should be sorted (setq company-idle-delay 0) ; default is 0.5 (setq company-minimum-prefix-length 3) ; default is 4 (setq company-selection-wrap-around t) ; When you reach the final, jump to the first (setq completion-ignore-case t) (setq company-dabbrev-downcase nil) (global-set-key (kbd \u0026#34;C-M-i\u0026#34;) \u0026#39;company-complete) (define-key company-active-map [tab] \u0026#39;company-select-next) ;; select with tab (define-key emacs-lisp-mode-map (kbd \u0026#34;C-M-i\u0026#34;) \u0026#39;company-complete) ;; yasnippet (defvar company-mode/enable-yas t \u0026#34;Enable yasnippet for all backends.\u0026#34;) (defun company-mode/backend-with-yas (backend) (if (or (not company-mode/enable-yas) (and (listp backend) (member \u0026#39;company-yasnippet backend))) backend (append (if (consp backend) backend (list backend)) \u0026#39;(:with company-yasnippet)))) (setq company-backends (mapcar #\u0026#39;company-mode/backend-with-yas company-backends)) (require \u0026#39;yasnippet) (add-to-list \u0026#39;load-path \u0026#34;~/.emacs.d/plugins/yasnippet\u0026#34;) (yas-global-mode 1) Before using company, you should install yasnippet. yasnippet means Yet Another Snippets.\n$ git clone --recursive https://github.com/joaotavora/yasnippet ~/.emacs.d/plugins Without this, you can use auto completion but the cursor doesn\u0026rsquo;t move to appropriate position and some invalid texts exists in the file.\nivy ivy is command completion package. There is helm similar to this, but I feel ivy is faster.\nThere are some packages using ivy.\ncounsel counsel enables you refine search.\n ;; ivy (require \u0026#39;ivy) (ivy-mode 1) (setq ivy-use-virtual-buffers t) (setq enable-recursive-minibuffers t) (setq ivy-height 30) ;; bigger minibuffer size (setq ivy-extra-directories nil) (setq ivy-re-builders-alist \u0026#39;((t . ivy--regex-plus))) ;; counsel (global-set-key (kbd \u0026#34;M-x\u0026#34;) \u0026#39;counsel-M-x) (global-set-key (kbd \u0026#34;C-x C-f\u0026#34;) \u0026#39;counsel-find-file) ;; get counsel to find file (setq counsel-find-file-ignore-regexp (regexp-opt \u0026#39;(\u0026#34;./\u0026#34; \u0026#34;../\u0026#34;))) swiper swiper is word search package. By using ivy, it\u0026rsquo;s really fast. And also it can do fuzzy search or retrieval search with multiple words.\n;; Swiper (global-set-key \u0026#34;\\C-s\u0026#34; \u0026#39;swiper) (setq swiper-include-line-number-in-search t) find-file-in-project You can find files by file name.\n recentf You can find files by your file history. This is really good tool for jump to a many files. For example, I\u0026rsquo;m writing this article (this article file is in ~/blog/content/post/2020-09-07-modernize-emacs/index.md) checking my ~/.emacs.d/init.el. It takes high cost to jump between these files since each file path is so long. Then this recentf works fine.\n;; recentf (require \u0026#39;recentf) (recentf-mode 1) (setq recentf-save-file \u0026#34;~/.emacs.d/.recentf\u0026#34;) (setq recentf-max-menu-items 25) (setq recentf-max-saved-items 25) (setq recentf-exclude \u0026#39;(\u0026#34;.recentf\u0026#34;)) (setq recentf-auto-cleanup \u0026#39;never) (require \u0026#39;recentf-ext) (define-key global-map (kbd \u0026#34;C-r\u0026#34;) \u0026#39;counsel-recentf) Rust, Go, Python I love Rust. And sometimes I write Go and Python.\nI\u0026rsquo;ll show each language setting.\nRust About Rust, I use rustic. This contains lsp, which is rust-analyzer as default.\nFor more infomation about this, see its repository.\n;; Rust (require \u0026#39;rustic) (setq-default rustic-format-trigger \u0026#39;on-save) (setq rustic-rustfmt-bin \u0026#34;~/.cargo/bin/rustfmt\u0026#34;) (add-to-list \u0026#39;rustic-rustfmt-config-alist \u0026#39;(\u0026#34;edition\u0026#34; . \u0026#34;2018\u0026#34;)) ;;(setq rustic-lsp-server \u0026#39;rls) (setq lsp-rust-analyzer-server-command \u0026#39;(\u0026#34;~/usr/local/bin/rust-analyzer\u0026#34;)) rustfmt runs when you save changes. And I have installed rust-analyzer via Homebrew, so here is set the path.\nNote: rustic's rust is edition 2015 as default, so you should add edtiion 2018 to setting.\nGo It\u0026rsquo;s easy to set your Emacs as Go IDE because all you have to do is hook with LSP. Thanks LSP!\n;; Go (require \u0026#39;go-mode) (add-to-list \u0026#39;exec-path (expand-file-name \u0026#34;~/go/bin/\u0026#34;)) (add-hook \u0026#39;go-mode-hook #\u0026#39;lsp-deferred) Python About Python, elpy is a inclusive package, which includes some config, linter or etc.\n;; Python (add-to-list \u0026#39;exec-path (expand-file-name \u0026#34;~/.pyenv/shims/\u0026#34;)) (add-to-list \u0026#39;exec-path (expand-file-name \u0026#34;~/.local/bin/\u0026#34;)) (use-package elpy :ensure t :init (elpy-enable)) Theme and modeline My theme and modeline are based on Doom.\n; cat in modeline (nyan-mode 1) ;; modeline (use-package doom-themes :custom (doom-themes-enable-italic t) (doom-themes-enable-bold t) :custom-face (doom-modeline-bar ((t (:background \u0026#34;#6272a4\u0026#34;)))) :config (load-theme \u0026#39;doom-vibrant t) (doom-themes-neotree-config) (doom-themes-org-config)) (use-package doom-modeline :custom (doom-modeline-buffer-file-name-style \u0026#39;truncate-with-project) (doom-modeline-icon nil) (doom-modeline-major-mode-icon nil) (doom-modeline-minor-modes nil) :hook (after-init . doom-modeline-mode) :config (line-number-mode 0) (column-number-mode 0) (doom-modeline-def-modeline \u0026#39;main \u0026#39;(bar window-number matches buffer-info remote-host buffer-position parrot selection-info) \u0026#39;(misc-info persp-name lsp github debug minor-modes input-method major-mode process vcs checker))) (use-package hide-mode-line :hook ((neotree-mode imenu-list-minor-mode minimap-mode) . hide-mode-line-mode)) With nyan-mode, you can always look a cute cat.\nwhich-key Actually I\u0026rsquo;m not familiar with Emacs key binds. which-key provides you information about the meaning of each key bind.\n;; which key (use-package which-key :diminish which-key-mode :hook (after-init . which-key-mode)) Summary My custom key bindings are like below.\n(global-set-key (kbd \u0026#34;M-x\u0026#34;) \u0026#39;counsel) (global-set-key (kbd \u0026#34;C-s\u0026#34;) \u0026#39;swiper) (global-set-key (kbd \u0026#34;C-r\u0026#34;) \u0026#39;counsel-recentf) (global-set-key (kbd \u0026#34;C-o\u0026#34;) ","categories":["Tech"],"date":1599436800,"description":"Emacs has old years but today it is considered to be ancient weapon. Here I'll modify it.","permalink":"http://komi.dev/post/2020-09-07-modernize-emacs/","publishdate":"2020-09-07T00:00:00Z","section":"post","tags":["Emacs"],"title":"Modernize Emacs","url":"/post/2020-09-07-modernize-emacs/"},{"body":"About WebAssembly First of all, you have to understand what WebAssembly is.\nMozilla says \u0026hellip;\n WebAssembly is a new type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.\n To tell simply, WebAssembly is fast language running on browsers. And people say WebAssembly as WASM in an shortened name.\nIn developing some application running in browsers, you have to write JavaScript to express complicated logic and provide rich UI in client side. Of course, it\u0026rsquo;s OK if you want to just make application. But sometimes JavaScript can be a bottleneck in application\u0026rsquo;s performance. For this, there are two reasons:\n Big binary size: JavaScript has big runtime Slow: To compile JavaScrit takes high cost  JavaScript can express complicated logic and rich UI, but can be problem today\u0026rsquo;s modern Web application. For example, 3D game, AR/VR and computer vision takes high cost to work. Because of this, modern browser expects faster system.\nHere, it\u0026rsquo;s WebAssembly to solve this problem.\nFor more information about WebAssembly, see MDN.\nTools You have already grasped what WebAssembly is. In the next stage, let\u0026rsquo;s understand what tool there are in developing WebAssembly.\nAs a result, you can develop WebAssembly with C/C++, Go, Rust or etc. You have many choice, but here I recommend Rust.\nIf you use C/C++, you have to use emscripten to compile your code into WebAssembly. emscripten is used to import JavaScript from C/C++ and also outputs JavaScript from LLVMIR. But emscripten cannot optimise codes and the ecosystem in developing is a little weak.\nIf you use Go, you can make WebAssembly code just by setting compile target. But Go has garbage collection to manage computer memory, and the binary size can be larger (this kills WebAssembly\u0026rsquo;s merit)\nThen, your choice is only one: Rust.\nWhen developing WebAssembly in Rust, wasm-bindgen makes your developing experience more comfortable. wasm-bindgen is a tool to run Rust code in browsers, developed by Mozilla. And this offers newer and better ecosystem than emscripten.\nActually, emscripten is also able to compile Rust code to WebAssembly. Here I will compare wasm-bindgen with emscripten.\nemscripten emscripten is compiler of C/C++ into asm.js or WebAssembly via LLVMIR. But it\u0026rsquo;s a little hard to use if you use only this. As a helper tool for compiling with emscripten, there is Binaryen, which is kind of wrapper of emscripten.\nSo far, these are not only for Rust but for C/C++. To compile Rust code into WebAssembly, you have to use emscripten-sys, stdweb and cargo-web.\n emscripten-sys: A crate for bindings of runtime of emscripten from Rust. stdweb: A crate for bindings of DOM from Rust. cargo-web: A build tool like npm. This includes stdweb.  These tools for Rust seems no longer developed since last commit is 1 year ago.\nwasm-bindgen wasm-bindgen is a tool to run Rust in browser, developed by Mozilla. This tool is used to import Rust code from JavaScript.\nThere are some helper tools for this.\n wasm-bindgen: A crate including types. js-sys: A crate to run JavaScript code in Rust. web-sys: A crate to help Rust use DOM. wasm-bindgen-futures: A crate to interact between Future type of Rust and Promise type of JavaScript wasm-bindgen-cli: A build tool to add runtime of FFI of Rust and JavaScript to wasm file made with wasm-bindgen, js-sys and web-sys. wasm-pack: A build tool to compile Rust code into wasm file and make package of npm.  Start Project OK, let\u0026rsquo;s start WebAssembly project.\nFirst, install wasm-pack.\n$ cargo install wasm-pack Next, make project directory with wasm-pack.\n$ wasm-pack new {ProjectName} Then, your directory will be like this:\n. ├── Cargo.toml ├── LICENSE_APACHE ├── LICENSE_MIT ├── README.md ├── src │ ├── lib.rs │ └── utils.rs └── tests └── web.rs When starting WebAssembly project, you have to set crate-type = [\u0026quot;cdylib\u0026quot;, \u0026quot;rlib\u0026quot;] in Cargo.toml to handle wasm file. And make sure there is wasm-bindgen as dependencies in Cargo.toml.\nIn src/lib.rs, there is some functions to run alert function in browser as default.\nLet\u0026rsquo;s build your project and say Hello World !\n$ wasm-pack build --target web This target flag means --target web turns on including ES modules.\nThen, you can find pkg/ directory has been made. In this directory, there are .wasm file and its helper or driber (for example, *.d.ts is type definition file)\nFinally, make pkg/index.html and write like this:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;hello-wasm example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import * as mod from \u0026#34;./{ProjectName}.js\u0026#34;; (async () =\u0026gt; { await mod.default(); mod.greet(); })(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Here we want to import .wasm file, so we set type=\u0026quot;module\u0026quot; in script tag. (if just \u0026lt;script\u0026gt; ... \u0026lt;/script/, you cannot import files).\nNow, your directory structure is like this:\n. ├── Cargo.lock ├── Cargo.toml ├── LICENSE_APACHE ├── LICENSE_MIT ├── README.md ├── pkg │ ├── README.md │ ├── index.html │ ├── {ProjectName}.d.ts │ ├── {ProjectName}.js │ ├── {ProjectName}_bg.d.ts │ ├── {ProjectName}_bg.js │ ├── {ProjectName}_bg.wasm │ └── package.json ├── src │ ├── lib.rs │ └── utils.rs ├── tests │ └── web.rs └── target └── ... Finally, run any server (for example, miniserver or python -m http.server 8000) and check browser.\n You are already WebAssembly developer!\nOther approach Not convinced? Then, run wasm file with Deno!\nMake add.rs!\n#![no_main]#![no_std]#[panic_handler]fn panic(_info: \u0026amp;core::panic::PanicInfo)-\u0026gt; !{loop{}}#[no_mangle]pubfn add(a: i32,b: i32)-\u0026gt; i32 {a+b}: And compile it.\n$ rustc --target wasm32-unknown-unknown add.rs Then, make main.js.\nconst bin = Deno.readFileSync(\u0026#34;./add.wasm\u0026#34;); const wasm = await WebAssembly.instantiate(bin); const ex = wasm.instance.exports; const add = ex.add; console.log(add(1, 2)); Finally, run this.\n$ deno run -A main.js You can find this wasm file also works!\n","categories":["Tech"],"date":1599350400,"description":"There are many tools around WebAssembly, and they are a bit complicated. Here you can find some clue to develop application using WebAssembly.","permalink":"http://komi.dev/post/2020-09-06-ecosystems-of-wasm/","publishdate":"2020-09-06T00:00:00Z","section":"post","tags":["Rust","WebAssembly"],"title":"Tools and Ecosystem of WebAssembly with Rust","url":"/post/2020-09-06-ecosystems-of-wasm/"},{"body":"About me Hello, my name is Yusuke Kominami.\nI\u0026rsquo;m living in Japan, and working as a machine learning engineer. I\u0026rsquo;m 23 years old and graguated from Kyoto University in this March. When I was student, I majored in Bioinformatics.\nWhy am I a software engineer?\nActually, I\u0026rsquo;m not interested in Biology, more interested in computing. So when I was in university, I just stuck on programming.\nFor more about me, see my Twitter or LinkedIn.\nWhy to start Blog? Today, it\u0026rsquo;s more and more important to offer tech information. This is because to do this makes me well-known in software developers community and able to get more opportunity. In other aspects, modern computer system and Web programming are really complicated, and today there are many software engineers in the world. This means there may be software developers who are stuck in the same problem at the same time. But if someone developed some solution, others should see it to avoid wasting time.\nThat\u0026rsquo;s why I started tech blog.\nHow to build Blog OK, we are ready to start blog. Here we will use Hugo and GitHub Actions.\nHugo is a static site generator, written in Go. It\u0026rsquo;s blazingly fast and really stable. And also there is a big community and there are so many themes.\nGitHub Actions is a platform to build and deploy your blog. The way to use this is really easy: just make a new repository and set a .yaml file in the repository.\nSetup Hugo If you use macOS, you can get Hugo via Homebrew.\n$ brew install hugo For other OS, check this page.\nIf OK, type below command to make sure you have Hugo.\n$ hugo --version Can you see some version info in your terminal? Then, you are OK.\nNext, we will make Blog repository. Type below command.\n$ hugo new site {YourBlogName} In this {YourBlogName}, anything is OK. For example, hugo new site MyBlog. When done, you can see there is a directory named {YourBlogName} in your directory.\nLet\u0026rsquo;s dive into this directory. Here we have some directoies and a config file.\n. ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes Hugo enables us to use site theme. In this tutorial, we will use clean-white. This is like this: Actually I use this theme in my blog (but customed a little). I love this theme because this has many options and is really simple and cool.\nLet\u0026rsquo;s clone this repository into your local directory.\n$ git clone https://github.com/zhaohuabing/hugo-theme-cleanwhite.git themes/hugo-theme-cleanwhite Next, edit config.toml to reflect this theme. To do this, add theme = \u0026quot;hugo-theme-cleanwhite\u0026quot;\nThen, your config file is like this.\nbaseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;hugo-theme-cleanwhite\u0026#34; OK, let\u0026rsquo;s build this site. Type below command.\n$ hugo server Good job! You already have your own site!\nDo you want to add some article? Just add some markdown file.\n$ hugo new post/hello-world.md Then you can see this new article in your site.\nFurthermore This theme has many options: sidebar, feature tags, SNS link, or more. If you want to turn on these options, see this config of examle site.\nAs a side note, this blog\u0026rsquo;s config is like this:\nbaseURL = \u0026#34;http://komi.dev\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;Launch Today\u0026#34; theme = \u0026#34;hugo-theme-cleanwhite\u0026#34; preserveTaxonomyNames = true paginate = 5 hasCJKLanguage = true [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] [params] custom_css = [\u0026#34;css/custom-font.css\u0026#34;] header_image = \u0026#34;img/home.jpg\u0026#34; SEOTitle = \u0026#34;Kominami Blog\u0026#34; description = \u0026#34;Yusuke Kominami\u0026#39;s Blog. About software engineering, career, lifestyle.\u0026#34; keyword = \u0026#34;Yusuke Kominami, 小南佑介, 小南 佑介, Rust, Emacs, Lisp, Web, Machine Learning, 機械学習\u0026#34; slogan = \u0026#34;Playground and Workspace for Awesome Ideas\u0026#34; title = \u0026#34;Launch Today\u0026#34; thumbnail = \u0026#34;img/home.jpg\u0026#34; image_404 = \u0026#34;img/404-bg.jpg\u0026#34; title_404 = \u0026#34;Page Not Found :(\u0026#34; omit_categories = false # Sidebar settings sidebar_about_description = \u0026#34;Software Developer, Rustacean, Open Source Enthusiast\u0026#34; sidebar_avatar = \u0026#34;img/me.jpg\u0026#34; featured_tags = true featured_condition_size = 1 about_me = true [params.social] rss = true email = \u0026#34;yusuke.kominami@gmail.com\u0026#34; github = \u0026#34;https://github.com/komi1230\u0026#34; facebook = \u0026#34;https://www.facebook.com/1230komi/\u0026#34; linkedin = \u0026#34;https://www.linkedin.com/in/yusuke-kominami-0419b1157/\u0026#34; [[params.addtional_menus]] title = \u0026#34;ABOUT\u0026#34; href = \u0026#34;/top/about/\u0026#34; [markup] [markup.tableOfContents] endLevel = 2 startLevel = 1 [markup.highlight] style = \u0026#34;dracula\u0026#34; Deploy with GitHub Actions Next, do you want deploy this site and share it with others? OK, let\u0026rsquo;s do it.\nAt first, push your site to your repository.\n$ git init $ git add . $ git commit -m \u0026#34;initialized\u0026#34; $ git remote add origin https://github.com/{YourGitHubAccountID}/{RepositoryName} $ git push -u origin master Next, setup GitHub Actions. To do this, we have 2 ways.\n Add .yaml file locally and push it to your repository Add .yaml file in GitHub site  Difference between these is whether the interface in adding .yaml file is CUI or GUI. Here we will do it by CUI.\nMake directory named .github/workflows/ and .yaml file.\n$ mkdir -p .github/workflows $ touch .github/workflows/gh-pages.yml GitHub Actions runs with .github/workflows/gh-pages.yml, so this is needed.\nContent of this .yaml file should be like this:\nname:GitHubPages# Controls when the action will run. Triggers the workflow on push or pull request# events but only for the master branchon:push:branches:- master# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:deploy:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themesfetch-depth:0- name:SetupHugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;0.74.3\u0026#39;- name:Buildrun:hugo--minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{secrets.GITHUB_TOKEN}}publish_dir:./publicHere I don\u0026rsquo;t explain this, but this config make GitHub Actions deploy your site.\nOK push this to your repository. Then, GitHub Actions is running or have run in your repository. There is a green check mark.\nSetting config in repository So far, almost all jobs are done. Finally, we will share your site with others.\nSee Settings page in your repository. In the middle of the page, you can see GitHub Pages group. This setting handles which directory to deploy.\nHere, set source branch to gh-pages and the directory to /(root).\nCongratulations! You\u0026rsquo;ve done all jobs!\nCheck https://{YourGitHubAccoutID}.github.io/{RepositoryName}. Your site has been deployed.\nLinks  Hugo Hugo themes My site repository Sample config  ","categories":["Tech"],"date":1599264000,"description":"Inroduce myself and how to build this blog with Zola and GitHub Actions.","permalink":"http://komi.dev/post/2020-09-05-make-blog/","publishdate":"2020-09-05T00:00:00Z","section":"post","tags":["zsh","GitHub","GitHub Actions","GitHub Pages"],"title":"Hello My New Blog","url":"/post/2020-09-05-make-blog/"}]