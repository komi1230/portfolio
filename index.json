[{"body":"背景 先日なんとなくネットサーフィンしていたらターミナルアプリ一覧みたいな記事を見かけた。 自分は今まで惰性でmacOSでデフォルトでついているターミナルアプリを使っていて、特に不満はなかった。 範囲選択したときのハイライトが弱くて見にくかったというのはあるが\u0026hellip;.\nこの記事を見て色々試して、最初に紹介されていたAlacrittyというのを使ってみることにした。 どうやらRust製ということで速いらしい。\n早速試してみて、確かに速い。 ものすごく操作している感じが良く、URLをクリックするとブラウザに飛べるというありがたい機能も付いていた。\nしかし完璧ではなくて、日本語のIMEとあまり相性が良くなかった。 具体的にどういう症状があったかというと、\n 予測変換している段階だとターミナル上に字が出てこない 予測変換の際に候補を矢印キーで選択するとコマンドヒストリーが起動してしまう  などの問題があった。\nただ、自分は基本的にターミナルでは英語しか打ち込まないので問題ないと判断し、Alacriittyを普段使いに採用することにした。\nしかしやはり日本語入力が微妙なのは気になるもので、思い切って自分で直してみることにした。 気合を入れて本家のコードをforkしてきて「さあやってやるぞ」と手を入れ始めたのだが、これが地獄の入り口だった。\nObjective-C何もわからん問題 Alacrittyのコードを見てみると、GlutinというOpenGLユーティリティのようなクレートを使って画面を作ってるらしい。 つまりキー入力自体のハンドリングについては丸ごとそちら側に任せて、Alacritty自体はGlutinから受け取ったWindowEventをもとに表示をどうするかなどAPIを整えているという機能分割を行っていた。\nIssueを眺めていくとどうやらIMEの問題については既知だったらしく、いくつかIssueが立っていた(Cannot input japanese characters #1101, Support inline \u0026ldquo;input method\u0026rdquo; input #1613)\nディスカッションの様子を見ていると、どうやらAlacritty側に問題があるわけではなくWinitという低レベルOpenGLクレート側に問題があるらしい。\n依存関係としては Alacritty \u0026gt; Glutin \u0026gt; Winit となっているのだが、Glutinは内部で use winit::* ということをしていて実質的に何もしておらず、結論としてWinitを直せばAlacrittyが直るとのこと。(#comment)\nということでWinitの中身を見てみるが、やっていたことはObjective-Cのコードをひたすらラップしていたのである。 もちろん最終的には使いやすい形となるようWindowEvent関連の綺麗なstructやenumがまとまっているが、OSごとの差分をうまいこと吸収するために色々泥臭いことが行われており、そのうちmacOSの場合に行われていたのがObjective-Cのラップだった。\nちなみに最初のこの時点でIMEについては全く知らないしmacOSネイティブのアプリ開発の経験も無いからmacOSでのIME APIなんて何も知らない。 おかげさまで最初はWinitのコードを書いても何もわからなかった。\n調査を進めていく 何も知識が無くRustのコードが読み書きできる状態だったのでまずはコードを読んでわからない概念・単語を全てググっていく。\nNSViewとかNSTextView？てかNSって何の略？ コードを読んでいくとNSViewとかNSTextView、他にもNSRangeなどNSというPrefixがついた色々なものが出てくる。 もちろん知らない。\nググってみると以下の情報が出てきた。\n NeXTSTEP の権利がアップル社に移る時に開発言語のObjective-Cの権利もアップル社に移りました。そしてこのNeXTSTEPが現在のMac OS Xのベースになりました。また今から学習をはじめるObjective-Cには“NS”という文字で始まるクラスや関数が多数存在しています（クラスについては後の章で説明いたします）。このNSはNeXTSTEPの略称です。\n かつてAppleを追われたスティーブ・ジョブズはNeXTという会社を作ってNEXTSTEPというOSを販売していたが、Appleに吸収されその技術をベースに現在のmacOSができあがったため、NS〇〇というのはNeXT社の由来というものらしい。(引用元)\n逆に、今回Winitのデバッグで出てくるオブジェクトでNSというPrefixがついていればWinitではなくmacOS側のオブジェクトということになる。\nIMEを使うにはNSTextInputClientプロトコルを実装する(?) NSがmacOS側のオブジェクトというのはわかったが、ググってみるとNSTextInputClientプロトコルを実装すればIMEが機能するようになるらしい。\nプロトコルを実装するというのはピンとこなかったが、NSTextInputClientプロトコル内で使われるhasMarkedTextやselectedRange、insertTextなどの関数をアプリケーション内で動くように実装すればいいらしい。\n具体的に、例えば未確定文字列が存在するか確認するhasMarkedTextは以下のように実装する。\nextern\u0026#34;C\u0026#34;fn has_marked_text(this: \u0026amp;Object,_sel: Sel)-\u0026gt; BOOL{unsafe{trace!(\u0026#34;Triggered `hasMarkedText`\u0026#34;);letmarked_text: id=*this.get_ivar(\u0026#34;markedText\u0026#34;);trace!(\u0026#34;Completed `hasMarkedText`\u0026#34;);(marked_text.length()\u0026gt;0)asBOOL}}また、setMarkedTextは以下のようになる。\nextern\u0026#34;C\u0026#34;fn set_marked_text(this: \u0026amp;mutObject,_sel: Sel,string: id,_selected_range: NSRange,_replacement_range: NSRange,){trace!(\u0026#34;Triggered `setMarkedText`\u0026#34;);unsafe{letmarked_text_ref: \u0026amp;mutid=this.get_mut_ivar(\u0026#34;markedText\u0026#34;);let_: ()=msg_send![(*marked_text_ref),release];letmarked_text=NSMutableAttributedString::alloc(nil);lethas_attr=msg_send![string,isKindOfClass: class!(NSAttributedString)];ifhas_attr{marked_text.initWithAttributedString(string);}else{marked_text.initWithString(string);};*marked_text_ref=marked_text;}trace!(\u0026#34;Completed `setMarkedText`\u0026#34;);}この場合、事前にNSViewオブジェクト内にmarkedTextという変数を用意しておき、仮に日本語入力をしていて確定されてない文字列(未確定文字列、下線がついているやつ)があればOS側がsetMarkedTextを発火してこのmarkedTextに値を当て、hasMarkedTextはそれを参照する。\nNSTextInputClientとはこのようにキーを押したイベントに際して文字列入力の際の一連の処理を行ってくれる規則であり関数の発火を行ってくれるもので、プロトコルを実装するとは実際のアプリケーションでIMEを叩くために各関数の具体的な動作を定義する必要があるのである。\n試験的に動かす 今回Alacrittyを直すためだったが、修正に際して登場するクレートが3つもあるため、それぞれcloneしてくる。\nディレクトリの位置関係としては以下のようになる。\n. ├── alacritty/ │ ├── alacritty/ │ ├── alacritty_config_derive │ ├── alacritty_terminal │ ├── docs │ ├── extra ├── glutin │ ├── glutin │ ├── glutin_egl_sys │ ├── glutin_emscripten_sys │ ├── glutin_examples │ ├── glutin_gles2_sys │ ├── glutin_glx_sys │ └── glutin_wgl_sys └── winit ├── examples ├── src └── tests そしてAlacrittyをローカルで叩くが、依存するクレートをcrates.ioからとってくるのではなくローカルのものをとってきて欲しいのでCargo.tomlの依存クレートを以下のように直す。\nglutin = { version = \u0026quot;0.27.0\u0026quot;, default-features = false, features = [\u0026quot;serde\u0026quot;] } ↓ glutin = { path = \u0026quot;../../glutin/glutin\u0026quot;, version = \u0026quot;0.27.0\u0026quot;, default-features = false, features = [\u0026quot;serde\u0026quot;] } これでローカルのものを参照してくれる。 Glutinでも同様にローカルのWinitを参照するように直す。\nこれらをやった上でAlacrittyのリポジトリでcargo runをすればターミナルが立ち上がる。\nこれで準備OKになった。\nNSTextInputClientの挙動を修正する 下調べなどでものすごく時間がかかってしまったが、ようやく作業に取り掛かる。\nWinitではIMEの挙動を直すために色々structの仕様変更が入ったりしていたが、現在ではKeyboardInputというstructで未確定文字列の有無を格納するフィールドがある。 AlacrittyもWinitもIMEの修正に真っ最中らしく、Alacritty本体でもまだ未確定文字列の処理についてのハンドリングはfixされていない。(Alacrittyの中にskip_eventsという関数があり、その中にKeyboardInput { is_synthetic: true, ..}がある)\n今回動作確認するためにはまずAlacrittyがハンドリングするWindowEventで未確定文字列が存在する場合もキャッチして処理するようパターンマッチングの分岐条件を変更する。\nWindowEvent::KeyboardInput{input,is_synthetic: false,..}=\u0026gt;{processor.key_input(input);},↓WindowEvent::KeyboardInput{input,..}=\u0026gt;{processor.key_input(input);},次にWinitにて適切にKeyboardInputというstruct内にis_syntheticのboolが適切に入っているか確認する。\nが、見てみるとmacOSについてはまだ暫定的に全てfalseでは入るようになっている。 macOSについてはまだIME対応が完了していない中でstructの仕様を変更が入った経緯ということで、このようなコードになっていた。\n一旦これをいじって直して、早速実際のIMEのコードの修正に取り掛かる。\nsetMarkedTextとinsertTextとdoCommandBySelector IMEの修正にはmacOSのAPIを叩いているコードを障ればよく、Winitのsrc/platform_impl/macos/view.rsがそれに該当する。\nコードの見方として、中段くらいにあるlazy_static! { ... }の部分でクラスの宣言を行なっていてこの中にクラスメソッドや変数の宣言を行う。 宣言された関数についてはその後extern \u0026quot;C\u0026quot; fn ...のようにして具体的な関数の実装を行う。\n宣言されたクラスメソッドは色々あるが、この中でキー入力を担うのがsetMarkedTextとinsertTextとdoCommandBySelectorの3つで、それぞれの役割として\n   関数名 役割     setMarkedText 日本語などの入力の際に未確定の文字列をどう扱うかを決める。   insertText 確定文字列をフロントエンドに送る。英語入力の際はデフォルトでこれになる。   doCommandBySelector Cmd-sみたいなキーバインド。文字入力ではなくウィンドウ操作などが対象。    となっている。 文字列をフロントエンドに渡す操作はsetMarkedTextとinsertTextが担っている。\nsetMarkedTextでフロントに都度入力する フロントエンドに文字列を渡す方法として、以下のようにイベント情報のキューにpushしていく。\nletmutevents=VecDeque::with_capacity(characters.len());events.push_back(EventWrapper::StaticEvent(Event::WindowEvent{window_id: WindowId(get_window_id(state.ns_window)),event: WindowEvent::ReceivedCharacter(character),}));AppState::queue_events(events);この中のevent: WindowEvent::ReceivedCharacter(character)が肝で、insertTextではこのような操作を行なってくれているのだがsetMarkedTextはこの実装が行われていなかった。過去のログを探ってみたところ、どうやら実装者が英語圏の人でsetMarkedTextが何のためにあるのか知らなかったらしい。\nそんなわけでsetMarkedTextにも毎度フロントに文字列をpushするように変更。 setmarkedTextは各キー入力に対して毎回発火するので、全部入力するようにしているとねこと入力したらnねねkねこと何度も入力されまくることになる。 そのため毎回setMarkedTextが起動すると同時に直前の未確定文字列分だけDeleteキーを押す操作を擬似的に行わせる。\nこの操作として直前のカーソル位置の分だけまず全部削除して、その後新規の未確定文字列を全部入力させるという方針を取る。 つまり\nこんにちh ↓ (全部削除) ↓ こんにちは とした。 これで重複を無くすことができる。\n一つ要注意ポイントとして、Rustでは文字列型としてStringと\u0026amp;strがあるが、これらに対してtext.len()としてもUTF-8のデータ長が帰ってきてしまう。 つまり\u0026quot;こんにちは\u0026quot;.len()の値は15となってしまう。 そのため文字数をカウントする場合は\u0026quot;こんにちは\u0026quot;.chars().count()を使うのが正しい。\ninsertTextとsetMarkedTextの二重発火 これで完成かというとそうでもなく、macOSのAPIとして未確定文字列がある場合は毎回のキー入力に対してsetMarkedTextが起動するが、未確定文字列が確定された時はinsertTextが起動する。 つまりこのままだとこんにちはと入力した際にこんにちはこんにちはと2回入力される。 これを防ぐべく、isIMEActivatedという状態を示す変数をViewクラスに実装し、未確定文字列がある場合はtrueとなるようにした上で、これを起点にinsertTextの処理を適切にスキップさせれば良い。\n予測変換への対応 日本語入力を考えた時、漢字への変換などがある。 この変換は多くの場合はSpaceキーや矢印キーを用いて行われる(はず)なのだが、現状のままだと予測変換のためにSpaceキーを押したのに空白が入力されてしまったり、もしくは矢印キーを触ってコマンドヒストリーを取りに行ってしまったりする。\nそのため予測変換のためのキー操作をしているとき(未確定文字列が存在しているとき)、Spaceキーや矢印キーが押されたときは別の動作をさせる必要がある。 この処理はkeyDownの実装をいじれば良く、自前でis_arrow_or_space_keyのような関数を実装した上で、適切に処理をさせれば良い。\n以上でようやくmacOSにてAlacrittyでIMEが有効化されるようになった。\nまとめ 今回バグを直すためにIMEってナニソレ状態から調査を始めて、無事にバグを修正するところまで持っていけた。\nCocoaやAppkitの周辺の日本語情報はあまり転がっていなかったのでなかなか苦労したが、とても良い経験になった気がする。\n最後に出したPRはこちら。\n","categories":["Tech"],"date":1626739200,"description":"日本語のインライン入力を行うためのTextInputClientにおいて実装のメモ","permalink":"http://komi.dev/post/2021-07-20-enabling-ime-in-alacritty/","publishdate":"2021-07-20T00:00:00Z","section":"post","tags":["IME","macOS"],"title":"Alacrittyが日本語入力がおかしいのを直した","url":"/post/2021-07-20-enabling-ime-in-alacritty/"},{"body":"","categories":null,"date":1626739200,"description":"","permalink":"http://komi.dev/post/","publishdate":"0001-01-01T00:00:00Z","section":"post","tags":null,"title":"Posts","url":"/post/"},{"body":"DigdagとGCP Digdagはワークフローエンジンとして有名なソフトで、複数個のタスク間の依存関係からなるワークフローを定義し、そのワークフローの実行及び管理を行う。\n具体的に、複数テーブルのインポートを行いたいとなったとき、それらに対して逐次的にEmbulkを手で叩くのではなく、DigdagがうまいことEmbulkを叩いてくれる。\n+some_job: sh\u0026gt;: embulk run some_table.yaml.liquid そんなDigdagであるが、バッチ処理に非常によく使われるため、GCPやAWSに対応したコマンドがDigdag側に用意されている。 これは本来ならば上記のようにsh\u0026gt;オペレータでシェルでコマンドを叩くが、BigQuery関係だとbq\u0026gt;とかbq_ddl\u0026gt;といったコマンドが用意されている。\n+some_bq_job: bq\u0026gt;: queries/step.sql destination_table: other_project:other_dataset.other_table これは実質的にsh\u0026gt;: bq ...コマンドの糖衣構文だけど、これは比較的便利なのでよく利用される。\nGKEでのクレデンシャルのセット Digdagの公式ドキュメントにはbq\u0026gt;オペレータを利用する際はDigdagのSecretsにサービスアカウントキーをセットするよう書いてある。\nDigdagが動いているコンテナ内で以下のコマンドを叩けば良い。\n$ digdag secret --project [YOUR_PROJECT_NAME] --set gcp.credential=@/path/to/sa_key.json こうするとbq\u0026gt;オペレータを叩く際にこのサービスアカウントとして実行される。\nしかし、ここでポイントとして、このクレデンシャルはコンテナ全体でサービスアカウントが有効化されているわけではない。\nGKEでポッドの中に入ってクレデンシャルを叩くと、GKEを動作しているサービスアカウントが出てくる。\n$ gcloud config list サービスアカウントの有効化 bq\u0026gt;オペレータやbq_ddl\u0026gt;オペレータでは微妙にやりきれない作業などはたまにあり、その際は直接シェルでbqを叩きたいケースがある。\n例えばテーブルのスキーマに説明を付与したくて、そのスキーマ情報はJSONで保存されているときなど。\nこうした際はSQLにCREATE TABLE文でやる方法もあるが、それよりもbq updateでテーブル情報をアップデートする方が簡単だったりする。\nこの場合、意図的にDigdag内でサービスアカウントを有効化させるジョブを挟み込む必要があり、\n+auth_sa: sh\u0026gt;: gcloud auth activate-service-account --key-file=/path/to/sa_key.json +some_job: sh\u0026gt;: bq update my_dataset.my_table schema/my_table.json というようにすればサービスアカウントで実行ができる。\n","categories":["Tech"],"date":1616284800,"description":"DigdagとEmbulkでBigQueryにデータを流す際にクレデンシャルのスイッチでハマったポイント","permalink":"http://komi.dev/post/2021-03-21-gcp-credential-in-digdag/","publishdate":"2021-03-21T00:00:00Z","section":"post","tags":["digdag","gcp"],"title":"GKEにおけるDigdagでのGCPのクレデンシャルの取り扱い","url":"/post/2021-03-21-gcp-credential-in-digdag/"},{"body":"GitHub ActionsとCloud Run CI/CDというと有名なのはCircle CIだろう。 他にはTravis CIやGitLab CIあたり？(Travisはなんかもうすぐ死ぬみたいなのを聞いたような気もするけど)\nそんな中、GitHubが公式に提供しているCI/CDツールとしてGitHub Actionsがある。\n今回行っていた作業はGitHub ActionsからCloud RunへのCD環境を整えることだったのだけど、その過程で色々落とし穴にハマった。\nこれらのCI/CDツールはそれぞれで文法が異なっていたりしたことや、Cloud Runのサービスアカウントのセットにミスったことなどたくさん学んだことがあったので今回はここでまとめておこうと思う。\n設定ファイル 最終的な設定ファイルとしてはこのようになっている。\nname:DeploytoCloudRunon:push:branches:- masterenv:ENVIRONMENT:productionGCP_SA_KEY:${{secrets.GCP_SERVICE_ACCOUNT_KEY}}GCP_PROJECT_ID:${{secrets.GCP_PROJECT_ID}}GCP_REGION:${{secrets.GCP_REGION}}jobs:deploy:name:SetupECruns-on:ubuntu-lateststeps:- name:Checkoutuses:actions/checkout@v2# gcloudコマンドの設定- name:Installgcloudcommandandconfigurecredentialsuses:google-github-actions/setup-gcloud@v0.2.0with:service_account_key:${{env.GCP_SA_KEY}}project_id:${{env.GCP_PROJECT_ID}}# DockerにgcloudコマンドのCredentialを使わせる- name:AuthDockerwithgcloudcredentialsrun:| gcloud --quiet auth configure-docker# Dockerイメージを作成 (今回はとりあえずEcho Serverで)- name:BuildDockerimagerun:| docker pull ealen/echo-server# DockerイメージをContainer RegistryにPush- name:Publishimagerun:| export IMAGE_NAME=${ENVIRONMENT}_serverexportDOCKER_TAG=asia.gcr.io/${GCP_PROJECT_ID}/${IMAGE_NAME}:${GITHUB_SHA::8}dockertagealen/echo-server$DOCKER_TAGdockerpush$DOCKER_TAG- name:Deployrun:| gcloud run deploy sample-server \\--image$DOCKER_TAG\\--project$GCP_PROJECT_ID\\--region$GCP_REGION\\--platformmanaged\\--quiet割と簡単な感じなのだけど地味にハマったポイントがいくつかあったのでまとめておく。\nDockerにCloud SDKのCredentialを使わせる 当初はGitHub Actionsでgcloudコマンドを使えれば良いと思っていて、google-github-actions/setup-gcloudのREADMEに書いてある通りのことだけを設定ファイルに記述していた。\nしかし、今回はCloud Runにデプロイする関係で一度コンテナをContainer Registryへとあげておかなければならない。\nそのためにdocker pushコマンドを叩くわけだけども、このコマンドを叩くにはdocker自体がCloud SDKのCredentialを把握しておく必要がある。\nこれは\n$ gcloud --quiet auth configure-docker で実現される。\n環境変数とGitHub Actionsの変数で文法が違う GitHub Actionsでは環境変数とワークフロー内での変数はレイヤーが異なる。\nワークフロー内のenvオブジェクトに環境変数が入り込むのである。\nワークフロー変数(GITHUB_SHAやenv.GCP_PROJECT_IDなど)を使うには${{ some_value }}として使い、環境変数を使うには${some_value}か${{ env.some_value }}とすれば良い。\nこれの何にハマったかというと、環境変数については${some_value}はオッケーだが${ some_value }はダメなのである。\n空白を入れてはいけないというルール。\n同様に、ワークフロー変数については${{ GITHUB_SHA }}はオッケーだが${{GITHUB_SHA}}はダメである。\nこれに気づかずCIを30回以上コケさせた。\nGCPでの設定 GCPではやるべきことは\n GitHub Actionsで動かす用にサービスアカウントを作成 Cloud RunとContainer Registryで使えるロールを付与  の2点だけ。\nロールの付与については\n Service Account User Cloud Run Admin Storage Admin  の3つ。\nこれも結構簡単なのだが結構ハマった。\nContainer Registryという名のCloud Storage Container Registryはコンテナのデータベースという感じでDocker Hubみたいなものだが、中身はCloud Storageである。\nそのためサービスアカウントにはCloud Storageの権限を与えれば良いが、Cloud Storageの権限は\n ストレージの中身の操作に関するもの(閲覧、作成と消去) 別のサービスへストレージの中身を転送するもの  の2つがある。\nセキュリティの観点から最小限の権利だけを与えようと思って1つ目のもののAdminだけを設定したのだが、ずっとPermission Deniedになってしまっていた。\ndenied: Token exchange failed for project '[project-id]'. Caller does not have permission 'storage.buckets.create'. To configure permissions, follow instructions at: https://cloud.google.com/container-registry/docs/access-control 色々試してみた結果、Storage全体のAdmin権限を渡したら動くようになった。\nまとめ GitHub ActionsとCloud Runはめちゃくちゃ便利だけど少し慣れていないと罠にハマるので気をつけたい。\n","categories":["Tech"],"date":1611014400,"description":"GitHub ActionsとCloud Runは便利だがCI/CDの設定で今回陥った罠についてツラツラと書く","permalink":"http://komi.dev/post/2021-01-19-cloud-run-from-github-actions/","publishdate":"2021-01-19T00:00:00Z","section":"post","tags":["GitHub Actions","CI","GCP"],"title":"GitHub ActionsからCloud Runを叩く","url":"/post/2021-01-19-cloud-run-from-github-actions/"},{"body":"モチベーション 最近はWebRTCにハマっていて、別に何か作りたいものがあったからというわけでは無いのだけど単純に面白いから見ており、それに際してその周辺技術にぼちぼちコミットしたりしている(こんな感じ)。\nただ実際のところは本当に趣味といった具合なので詳細な部分についてはまだまだ勉強中だったりする。\nそんなわけでこの記事はある程度理解が進んだSDPについての勉強メモみたいな感じ。\nSDPとは まず最初にSDPとググるとだいたいゼロトラストの方のSDPが出てくる。\nゼロトラストのSDPはSoftware Defined Perimeterの略語で、WebRTCのSDPとは全くの別物であることに注意(ただ、WebRTCはP2P通信でファイアウォールなどのネットワークの壁をどう越えるかみたいなところが結構大変で、そこらへんの概念にゼロトラストのSDPみたいな考え方が出てきたりするので無関係というわけではなさそうだけども\u0026hellip;)。\nとりあえず今回の記事ではSDPとはSession Description Protocolだと最初に断っておきたい。\nオファーアンサーモデル さて、WebRTCにおけるSDPの話というわけだけど、WebRTCはP2P通信で、クライアントとクライアントが通信することになる。\n何を通信するかというと、音声だったりテキストだったり画像とか動画。 ただ、前提として各クライアントがどのメディアを使えるかはお互いに確認してみないと分からないのである。\nそこでお互いが何のメディアを使えるかを伝え合う所作をオファーアンサーモデルという。\n具体的には\nアリス「こっち電話とビデオいけるけどそっちどうよ？」 ボブ「あーこっち電話しか使えないんだわ」 的なやり取りである。\n仕様を眺めてみる SDPがP2P通信においてお互いがどのメディアを使用可能か確認するお作法であることはわかったので、具体的にどのようにやっていくかを見ていく。\nクライアント間では以下のようなデータがやり取りされる。\nv=0 o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5 s=SDP Seminar i=A Seminar on the session description protocol u=http://www.example.com/seminars/sdp.pdf e=j.doe@example.com (Jane Doe) c=IN IP4 224.2.17.12/127 t=2873397496 2873404696 a=recvonly m=audio 49170 RTP/AVP 0 m=video 51372 RTP/AVP 99 a=rtpmap:99 h263-1998/90000 このv=とかみたいなのはSDPにおけるDSLみたいなもので、それぞれがセッション情報だったり扱えるメディアについての情報、どのポート番号を解放するかなどを表している。\n簡単にいくと\n v= : セッションのバージョン番号。基本的に0で固定。 o= : 送信元の情報。 s= : セッション名。 i= : セッション情報。 u= : URI e= : メールアドレス。p=で電話番号が書かれることも。 c= : 接続データ。 b= : 帯域。 t= : タイミング、時間。スタートと終わりがUnixタイムで表現される。 r= : 繰り返し回数 z= : タイムゾーン k= : 暗号化キー a= : 属性情報、セッションの拡張情報 m= : メディア記述  という具合。\nこれらは全部が必須というわけではなくオプションのものもあるが、SDPの記述においてはいくつかの制約があったりする。\n具体的に言うと、例えばv=0などでは途中に空白を入れてはいけないことや、vやoなどの出現順序を間違えてはいけないことなどがある。\n詳しい話はこのSlideshareがめちゃくちゃわかりやすく解説してあるが、これの補足をいくつかしておく。\n m=行の数のオファーとアンサーで同一でなければいけないけど、互いに扱えるメディアの数が違う時はどうするの？  該当するメディアのポート番号を0として解放しない旨を示す   行の並びが指定されているけどm=が複数並んでる時は順序指定ってある？  audioを優先的に上にする。    ここら辺の仕様書は情報通信技術委員会が作ったものが参考になるので確認しよう。\nまた一番詳しいのはRFC4566なのでこれを読もう。\n","categories":["Tech"],"date":1609891200,"description":"WebRTCでは通信条件のネゴシエーションが必要だが、これを実現するためにSDPがある。ここではSDPがどのような形をしているかを見ていく。","permalink":"http://komi.dev/post/2021-01-06-about-sdp/","publishdate":"2021-01-06T00:00:00Z","section":"post","tags":["WebRTC","SDP"],"title":"WebRTCにおけるSDPを理解する","url":"/post/2021-01-06-about-sdp/"}]